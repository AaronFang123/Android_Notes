## 第一章 Android与Android Studio

### 1.Android系统重要概念

* 架构 自底向上：

| Linux内核 硬件驱动                        |
| ----------------------------------------- |
| 系统运行库层 SQLite OpenGL Webkit Runtime |
| 应用框架层 系统API能力                    |
| 应用层                                    |

* 四大组件

  Activity、Service、Broadcast Receiver（电话、短信等）、Content Provider（应用程序间共享数据）

### 2.Android Studio的项目组织架构

（切换成Project模式下的真实目录）

####  .gradle 和 .idea

AS自动生成的文件，无需关心

#### app

项目中的代码、资源等，开发工作基于此目录

#### build

编译时自动生成的文件

#### gradle

gradle wrapper配置文件

#### .gitignore

#### build.gradle

项目全局的构建脚本，~~通常不需要修改~~

```
 dependencies {
        classpath 'com.android.tools.build:gradle:3.5.1'
        classpath 'com.google.ar.sceneform:plugin:1.15.0'}
```



#### gradle.properties

全局的gradle构建脚本，这里配置的脚本会影响到所有gradle编译脚本

例如：

```
android.useAndroidX=true
```

#### gradlew与gradle.bat

用于命令行中执行gradle命令。前者用于unix-like，后者用于win

#### [项目名].iml

标识这是一个IntelliJ IDEA项目

#### local.properities

指定本机的Android SDK路径

```
sdk.dir=D\:\\AndroidSDK
```

#### setting.gradle

指定项目中引入的所有模块，如只引入了`app`模块

```
rootProject.name='ScenceFormDemo'
include ':app'
```

### 3.app目录下的内容及作用

#### build

编译文件

#### libs

第三方jar包，其下的jar包会自动添加进构建路径中

#### androidTest

存放AndroidTest自动化测试用例

#### java

java代码

#### res

资源，包括了

* drawable 图片资源

  * mipmap开头的文件夹用于保存应用图标(适配各种分辨率)

    若没有指定，建议放在`mipmap-xxhdpi`中

* layout 布局资源

* values 字符串资源 等

  * 在代码中`R.String.stringName`实现引用字符串
  * 在XML在`@String/stringName`实现引用字符串

#### AndroidManifest.xml

整个安卓项目的配置文件,四大组件,权限声明等

#### test

Unit Test测试

#### app.iml

#### build.gradle

app模块的构建脚本

* defaultconfig--> targetSdkVersion: 系统将在指定的版本号开放该版本的特有功能vv

* buildTypes -> release -> minifyEnable 是否开启混淆

* dependences 的依赖分为三种

  * compile fileTree 本地依赖

  * implementation 远程依赖   `域名:组名:版本`

    ```
     'androidx.appcompat:appcompat:1.1.0'
    ```

#### proguard-rules.pro

指定代码的混淆规则,难以破解安装包文件的源代码

### 4.注册活动及声明主活动

任何活动都要到AndroidManifest.xml中进行注册

注册主活动

```xml
<activity android:name=".MainActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```

**所有活动都要继承Activity类**

一般继承`AppCompatActivity`类, 是`Activity`的子类这是一种实现最低兼容到Android 2.1的向下兼容的Activity

**补充**：

activity中可以通过android：theme属性指定主题：

```xml
<activity android:name=".MainActivity"
    android:theme="@style/Theme.AppCompat.Dailog"
</activity>
```

**指定了主题是Dailog对话框式主题**

### 5.Log工具

格式` Log.x(tag, msg)` x见下  tag用于过滤,建议使用类名, msg填写具体信息                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

* `Log.v()`  打印verbose 是按照日志中最低的一级

* `Log.d()`  打印debug

* `Log.i()`  打印info

* `Log.w()`  打印warm

* `Log.e()`  打印error 严重问题

  在logcat中设置了级别时,只会向上显示相应的语句.

  如Log.v()语句 不会被logcat中的error条件显示

  

## 第二章 Activity的基本用法

### findViewById()

`findViewById(id) `返回的是`View`对象 注意要向下转型

```
Button button = (Button) findViewById(R.id.button)
```

### Toast

Toast通过静态方法 maketext(context, content, druation)创建对象,通过show()方法展示

一般上下文传入本活动的实例即可 `AnACtivity.this`

内容传入字符串

时长有两个

* `Toast.LENGTH_SHORT` 短时
* `Toast.LENGTH_LONG ` 长时

### 菜单menu

* 在res目录下新建menu目录

* menu目录 右键 -> new -> Menu resource File

* 添加`<item>`标签

  ```xml
  <item
        android:id:"@+id/add_item"
        android:title:"xxx"/>
  ```

* 在活动中重写`onCreateoptionsMene(Menu menu)`方法

  ```java
  @Override
  public boolean onCreateOptionsMenu(Menu menu){
  	getMenuInflater().infalte(R.menu.main, menu);
      //第一个参数是布局文件,第二个是重写方法时传入的menu对象
  	return true;
  }
  ```

* 重写`onOptionsItemsSeleted(MenuItem item)`方法

  ```java
  @override
  public boolean onOptionsItemsSeleted(MenuItem item){
  	switch (item.getItemId()){
  		case R.id.xxx:
  			//TODO
  			break;
  		case R.id.yyy:
  			//TODO
  			break;
          defalut:
  	}
  	return true;
  }
  ```

完成后,在Activity标题栏的右边(如果未被隐藏)有三个点的图标

### 销毁活动

`finish()`  等同于`Back`键

### Intent

(意图)

* 用于各个组件之间的交互,它不仅可以指明**当前组件想要执行的动作**,也可以**传递数据**

* 一般用于启动活动,发送广播,启动服务等场景

* 分为**显式Intent和隐式Intent**

  (以下Intent用于启动)

#### 显式Intent

1. 建立Intent对象 

   ```java
   Intent intent = new Intent(Context packageContext ,Class<?> cls);
   ```

   第一个参数 用于启动活动的上下文, 第二个参数指定要启动的目标活动

2. `startActivity(intent)`

例如:

```java
Intent intent = new Intent(AnActivity.this , newActivity.class);
startActvity(intent);    
```

#### 隐式Intent

不明确指出想要启动的活动,而是通过指定一系列更加抽象的`action`和`category`信息,交由系统分析出"合适的活动"

* 在AndroidManifest.xml文件下的对应的`<activity>`标签下增加`<intent-filter>`的内容,可以指定合适的action和category,**只有同时满足两者才能实现intent**

  ```xml
  <activity Android:name=".xxx">
  	<intent-filter>
  		<action android:name="[包名].ACTION_START" />
          <category android:name="zzz"/>
      </intent-filter>
  </activity>
  ```

  * 需要如此声明Intent,直接将`action`的**字符串**传进去,表明想要启动`ACTION_START`这个活动

  ```java
  Intent intent = new Intent("[包名].ACTION_START");
  startActvity(intent);
  ```

  ​	默认的category是`android.intent.category.DEFAULT`

  * 通过`intent.addCategory(String category)`来增加category

#### 隐式Intent调用其他应用程序的活动

也可以调用其他应用程序的活动

 1. 调用系统浏览器打开网页

    ```java
    // in a listener
    Intent intent = new Intent(Intent.ACTION_VIEW);//Intent.ACTION_VIEW 自带
    intent,setData(Uri.prase("http://www.xxx.com"));
    startActivity(intent);
    ```

    也可以在<intetn-filter>内增加更多标签满足更精确的隐式Intent

    `<data android:scheme:"http">`只响应http协议

2. 调用系统拨打电话

```java
// in a listener
Intent intent = new Intent(Intent.ACTION_DIAL);//Intent.ACTION_VIEW 自带
intent.setData(Uri.prase("tel:10086"));
startActivity(intent);
```

`<data android:scheme:"tel">`只响应tel协议

#### 隐式Intent在活动之间传递信息

##### 1.传递数据给下一个活动

发送方:`intent.putExtra("key", value)`

```java
// 前略 创建intent实例
intent.putExtra("key", "A message");
```

接收方 `get<?>Extra(k)`

```java
// onCreate()函数内
Intent intent = getIntent(); // 获取用于启动Activity的Intent
String data = intent.getStringExtra("key");
```

注意get<?>Extra内填写相应的数据类型

##### 2.返回数据给上一个活动

Activity内另外一个启动活动的方法`startActivityForResult(Intent intent)`,期望新的活动销毁时能够返回一个结果给上一个活动.

原活动:

​	1. startActivityForResult(Intent intent , int requestCode ), **需要声明请求码辨别来源**

```Java
// 创建好了一个Intent实例intent
startActivityForResult(intent, 1);
```

​	2.重写`onActivityResult()`用于接收

```java 
@override
protected void onActivityResult(int requestCode , int resultCode, Intent data){
	switch(requestCode){ // 判断数据来源
		case 1:
			if (resultCode == RESULT_OK){
				//TODO
				
			break;
        default:														}		
	}
}
```



新活动:

Intent构造方法参数为空

```java
//在某事件监听器内或onBackPress()内(监听返回键)
...
Intent intent = new Intent();
// 可以使用putExtra()添加传递的信息
intent.setResult(RESULT_OK, intent);
// 销毁 onBackPress()不需要
finish();        
```

setResult的第一个参数只能有两种选择`RESULT_OK`, `RESULT_CANCEL`

### 活动生命周期

#### 活动状态

* 运行状态: 返回栈
* 暂停状态 :不是活动态但是仍可见(对话框遮档)
* 停止状态: 不在栈顶位置,也完全不可见
* 销毁状态: 从返回栈中移除

#### 生存期

* onCreate(): 活动第一次被创建 应该完成活动的初始化操作 如加载布局,绑定事件等
* onStart() 不可见变可见时
* onResume() 准备好与用户交互 此时活动必然处于栈顶
* onPause() 在系统准备启动新活动是调用 用于保存关键数据 但一定要快
* onStop()  活动完全不可见前调用 
* onDestroy() 销毁之前调用 之后为销毁态
* onRestart() 停止状态 --> 运行态

#### 生存期

* 完整生存期 																

  onCreate()  -->  onDestroy()

* 可见生存期 对于用户可见时,即使无法与用户交互 

  onStart()  --> onStop()

* 前台生存期  可见而且可以与用户交互			        

   onResume()  --> onPause()

#### 活动被回收了怎么办 onSaveInstanceState()

一个活动到另外一个新的活动,原活动处于停止状态,可能被系统回收.从新活动返回时仍可以重新打开原活动,

执行`onCreate()`方法.但原来的数据被丢失.

`onSaveInastanceState(Bundle outside)`可以临时保存状态.

```java
@override
protected void onSaveInstanceState(Bundle outside){
	super.onSaveInstanceState(outside);
	outside.putString("A_key", "value");
}
```

在`onCreate()`中取出:

```java
onCraete(Bundle savedinstanceState){
	super.onCreate(savedinstanceState);
	setContentView(xxx);
	
	if(savedinstanceState !== null){
		String tempDate = savedinstanceState.getString("A_key");
	}
}
```

### 活动的启动模式

```xml
<activity android:name=".MainActivity"
    android:launchMode=xxx
</activity>
```

1. standard(默认): 新的活动都在栈顶, 不管这个活动在返回栈在是否存在
2. singeTop: 新活动启动时发现栈顶的活动已经是该活动, 直接使用它, 不创建新活动
3. singleTask: 使得某个活动在栈中只存在一个实例
4. singleInstance: 单独创建一个返回栈管理该活动, 不管是那个应用程序访问这个活动, 都共用这个返回栈, 从而实现共享

## 第三章 布局

###  android 控件可见属性

* visible: 可见且占据空间
* invisible：不可见但是占据空间
* gone ：不可见且不占据空间

使用`setVisibility()`方法设置， 可以传入

`View.VISIBLE`

 `View.INVIDIBLE` 

 `View.GONE`三种值

### ViewGroup

特殊的View,可以包含很多子View和ViewGroup

#### 线性布局LinearLayout

1. `android:orientation` 布局的方向 可选:horizontal vertical

2. `android:layout_gravity`: 控件在布局中的对齐方式

   `android:gravity `文字在控件中的对齐方式

3. `android:layout_weigth`

#### 相对布局RelativeLayout

可以使得控件出现在布局的任何位置

* 相对于父组件定位` layout_alignParent___ ="true"`

* 相对于其他控件布局 `layout_above = "@id/xxx"`

  `layout_to___Of = "@id/xxx"`

  引用其他控件的id

#### 帧布局FrameLayout

默认所有控件在左上角

`android:layout_gravity`: 上下左右  对齐的方向

### 引入布局

在其他布局中引入已经写好的布局

```xml
<include layout = "@layout/xxx">
```

隐藏系统自带的标题栏

```java
ActionBar ab = getSupportActionBar();
if(ab != null){
	ab.hide();
}
```

### 自定义控件

```java
public class NewLayout extends LinearLayout{
	public NewLayout(Context context, AttributeSet attrs){
		super(context, attrs);
		// 添加新布局
		LayoutInflater.from(context).inflate(R.layout.xxx, this);
        // TODO 添加有关动作
	}
}
```

`LayoutInflater.from(context)`得到一个`LayoutInflater`实例(布局填充器)

调用inflate方法动态加载布局, 第一个为布局文件id, 第二个是父布局

**可以在布局文件中直接使用**`NewLayout`

另外:

**获取View对象所在活动的方法**

```java
(Activity)getContext();
```



### ListView

#### 基本用法

1. 预先提供数据 `String data[] = {"A","B"}`

2. 建立Adapter  (Context context, sub_item_layout, data)

3. 找到listView实例

4. `setAdapter()`

   ```java
   // 2
   ArrayAdapter<String> adapter = new Adapter<String>(MainActivity.this,                                                   android.R.layout.simple_list_item_1,                                              data);
   // 3
   ListView lv =findViewById(xxx);
   // 4
   lv.setAdapter(adpter);
   ```

#### 定制界面

每个item_view 里有一张图片和一行文字

1. 数据类

```java
class Fruit{
    private String name;
    private int picId;
    
    Fruit(String name, picId){
        this.name = name;
        this.picId = picId;
    }
    
    public String getName(){
        return name;
    }
    
    public int getPicId(){
        return picId;
    }
}
```

2. 子类布局 略

3. 新建Adapter

   `resId`**用于指定当前某一项目布局文件(内部布局)**的id,

   `getView()`**每个划入屏幕范围的子项都会被调用**，在此加载其布局

   `convertView`**之前已经缓存的布局**

   ```java
   class FruitAdapter extends ArrayAdapter<Fruit>{
       // 子项布局文件的id
   	private int resId;
   	
   	public FruitAdapter(Context context, int textViewResourseId, List<Fruit> objects){
           super(context, textViewResourseId, objects);
           this.resid = textViewResourseId;
       }
       
       @override
       public View getView(int position, View convertView, ViewGroup viewgroup){
           Fruit fruit = getItem(position);
        // 为这个子项加载布局   
           View view = LayoutInflater.from(getContext()).inflate(resId,parent,false);
           ImageView imageview = view.getViewById(R.id.image);
           TextView textview = view.getViewById(R.id.text);
           imageview.setImageResource(fruit.getRPicId());
           textview.setText(fruit.getName());
           return view;
       }
   }
   ```

4. 掺入数据（MainActivity.java）

   ```java
   // 创建数据List
   List<Fruit> fruitList = new ArrayList<>();
   // 
   onCreate(){
       // ...
       // 填充List
       initFruit();
       FruitAdapter fruitadpater = new FruitAdapter(MainActivity.this, R.layout.xxx, fruitList);
       ListView lv = findViewById(xxx);
       lv.setAdapter(fruitadpater);
   }
   
   initFruit(){
       Fruit firit_1 = new Fruit("apple", R.drawable.xxx);
       fruitList.add(firit_1);
       // ...
   }
   ```

#### 优化之Adapter的内部类ViewHolder

`ViewHolder`可以用于缓存子项内部的实例，免得每次加载子项都要去`findViewById()`

```java
class FruitAdapter extends ArrayAdapter<Fruit>{
    // 子项布局文件的id
	private int resId;
	
	public FruitAdapter(Context context, int textViewResourseId, List<Fruit> objects){
        super(context, textViewResourseId, objects);
        this.resid = textViewResourseId;
    }
    
    @override
    public View getView(int position, View convertView, ViewGroup, viewgroup){
        Fruit fruit = getItem(position);
        View view ;
        
     	ViewHolder viewholder;
        // 如果之前没有缓存过布局
        if(convertView == null){
            view = LayoutInflater.from(getContext()).inflate(resId,parent,false);
            viewHolder = new ViewHolder();
            viewholder.textview = view.getViewById(R.id.text);
            viewholder.imageview = view.getViewById(R.id.image);
            // 将ViewHolder保存在view中
            view.saveTag(viewholder);
        }
        // 如果不为空，直接取来用
    	else{
            view = convertView；
            // 重新获取VIewholder
            viewholder = view.getTag();
        }
        viewholder.imageview.setImageResource(fruit.getRPicId());
        viewholder.textview.setText(fruit.getName());
        return view;
    }
    
    class ViewHolder{
        // 缓存实例
        TextView textview;
        ImageView imageview;
    }
}
```

### RecycleView 更推荐的滚动控件

`ViewHolder`内部要存放子控件**内控件的实例**，接收一个View对象，是**子布局的布局文件实例**

`FruitAdapter`构造函数完成数据的传入

`onCreateViewHolder`作用是创建`ViewHolder`实例并返回

`onBindViewHolder`对子项数据进行赋值, 根据`position`, 在每个子项滚动到屏幕内时执行

`getItemCount`简单返回子项数目即可

```java
import java.util.List;

public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder>{
    // 数据部分
    private List<Fruit> mFruitLists;

    static class ViewHolder extends RecyclerView.ViewHolder{
        IamegeView fruitImg;
        TextView fruirName;

        public ViewHolder(View view){
            super(view);
            fruitImg = (ImageView)view.findViewById(R.id.xxx);
            fruirName = (TextView)view.findViewById(R.id.yyy);
        }
    }

    public FruitAdapter(List<Fruit> fruitList){
        this.mFruitLists = fruitList;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int ViewType){
        View view = LayoutInflater.from(getContext()).inflate(R.layout.zzz, parent, false);
        ViewHolder holder = new ViewHolder(view);
        return holder;
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position){
        Fruit fruit = mFruitLists.get(position);
        holder.fruitImg.setImageResource(fruit.getPicId());
        holder.fruirName.setText(fruit.getName());
    }

    @Override
    public int getItemCount(){
        return mFruitLists.size();
    }

}
```

MainActivity.java

`LayoutManager`用于指定RecyclerView的布局方式, `LinearLayoutManager`指的是线性布局, 默认纵向

```java
// onCreate()内
initFruit();
RecyclerView recyclerview = (RecyclerView)findViewById(R.id.aaa);
//
LinearLayoutManager layoutManager = new LinearLayoutManager(this);
recycelerView.setLayoutManager(layoutManager);
//
FruitAdapter fa = new FruitAdapter(fruitList);
recyclerview.setAdapter(fa);
    
```

改为横向排列

```
layoutManager.setOrientation(LayoutManager.HONRIZONTAL);
```

* 对于有多种样式的控件，可以在同一个文件声明多种布局，**根据需要更改各个控件的可见性**，但仍然要获取所有控件的实例。实现(Vue中 v-if条件编译)的效果

* 当数据渲染后追加数据（通常是向一个List追加数据时），需要向adapter**声明追加, 需要刷新布局**

  参数：变更之后的长度int

  ```java
  adapter.notifyItemInserted(msgList.size());
  ```

  有需要可以使其滚到最后 

  参数：位置int

  ```java
  // msgRecyclerView是RecyclerView的实例
  msgRecyclerView。srcollToPosition(msgList.size() -1 )
  ```

  

## 第四章 fragment碎片

碎片Fragment是一段可以嵌入活动中的UI片段

**可以理解成是迷你的活动**

### 基本用法 显式添加碎片

1. 创建碎片的布局 （LeftFragment.xml RightFragment.xml）

2. 创建相应的类 (leftFragement为例)

   继承Fragment类

   重写onCreateView方法, 获取view对象

   ```java
   public class LeftFragment extends Fragment{
       @override
       public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInatanceState){
           View view = inflater.inflate(R.layout.LeftFragment, container, false);
           return view
       }
   }
   ```

3. 创建容纳布局的大布局文件

   ```xml
   <LinearLayout xxx>
       <fragment
            android:id="@+id/xxx"
            android:name="[指定布局添加碎片的类名的包路径]"
       .../>
   </LinearLayout>
   ```

4. MainAtivity中默认基本载入3中布局即可

### 动态加载碎片

1. 在大的布局文件中使用`FrameLayout`占位

   ```xml
   <LinearLayout xxx>
       <fragment
            android:id="@+id/xxx"
            android:name="[指定布局添加碎片的类名的包路径]"
       .../>
       <FrameLayout
        	android:id="@+id/yyy"
                    />
   </LinearLayout>
   ```

2. 事先完成 显式添加碎片中的1, 2两个步骤

3. 在`MainActivity`中添加如下函数以完成替换功能

   

   ```java
   private void repalceFragment(Fragment fragment){
       // 1.获取fragmentManger, 在活动在直接通过 getSupportFragmentManager()得到
       FragmentManager fragmentManger = getSupportFragmentManager();
       // 2.开启一个事务
       FragmentTransaction transaction = fragmentManager.beginTransaction();
       // 3.替换传入 (被替换的容器id, 新的碎片实例)
       transaction.replace(R.id.yyy, fragment);
       // 4.提交事务
       transaction.commit();
   }
   ```

   调用

   ```java
   replaceFragment(new RightFragment());
   ```

   ### 模拟返回栈

   ```java
   private void repalceFragment(Fragment fragment){
       // 1.获取fragmentManger, 在活动在直接通过 getSupportFragmentManager()得到
       // FragmentManager fragmentManger = getSupportFragmentManager();
       // 2.开启一个事务
       // FragmentTransaction transaction = fragmentManager.beginTransaction();
       // 3.替换传入 (被替换的容器id, 新的碎片实例)
       // transaction.replace(R.id.yyy, fragment);
       // 4.加入返回栈
       transaction.addToBackStack(null);
       // 5.提交事务
       // transaction.commit();
   }
   ```

   

### 碎片与活动之间的通信

#### 活动中获取碎片实例

MainActivity.java

```java
SampleFragment sampleFragment = (SampleFragment)getSupportFragmentmanager()
    .findFragmentByid(R.id.zzz);
```

#### 碎片中获取实例

SampleFragment.java

```java
MainActivity activity = (MainActivity) getActivity();
```

### 生命周期

* onAttach() 单碎片与活动建立关联时调用
* onCraeteView() 为碎片创建视图 加载布局时调用 
* onActivityCreated() 确保与碎片相关联的活动创建完毕时调用
* onDestoryView() 当与碎片关联的试图被移除时调用
* onDetch() 单碎片与试图解除关联时调用

### 适配大屏

在res目录下新建``layout-large`目录, 里面的布局会在被认为是大盘的设备上加载.

自定义:最小宽度限定符`layout-sw[]dp`

sw = samllest width , []填数字 

## 第五章 广播和广播接收器BroadCast Receiver

### 分类

* 标准广播  完全异步，所有广播接收器都同一时刻接收到消息
* 有序广播  按序传播，可以被截断

### 接收系统广播

* 广播接收器可以选择自己感兴趣的广播进行注册

  注册广播的方式有**动态注册**(代码中注册)， **静态注册**（AndroidManifaest.xml）两种

* 创建广播接收器的方法: **新建一个类, 继承自`BroadcastReceiver`类即可,** 广播到来时`onReceive()`方法可以得到触发



#### 动态注册

动态注册只有当程序启动后才会执行

MainActivity.java

```java
public class MainActivity extends AppCompatActivity{
    //
    private IntentFilter intentFilter;
    //
    private NetworkChangeReceiver networkChangeReciver;
    
    @override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.xxx);
        
        // 建立IntentFilter对象
        intentFilter = new IntentFilter();
        // 想要监听什么广播,在addAction方法在添加
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        networkChangeReceiver = new NetWorkChangeReceiver();
        // 注册广播接收器
        resigerReciver(networkChangeReceiver, intentFilter);
    }
    
    protected void onDestory(){
        super.onDestory();
        // 取消已经注册的监听器
        unregsiterReceiver(networkChangeReceiver)
    }
    // 新建一个接收器,注意onReceive的参数列表
    class NetWorkChangeReciver extends BroadcastReceiver{
        @override
        public void onReceive(Context context, Intent intent){
            Toast.makeText(...).show();
        }
    } 
}
```

注册监听器

` resigerReciver(sub_BroadcastReceiver receiver, intentFilter intentFilter);`

注销监听器

`unresigerReciver(sub_BroadcastReceiver receiver)`; 

扩展:获取当前网络状态的方法

```java
// 获取系统服务 网络连接管理器
ConnectivityManager connectivityManager = getSystemManager(Context.CONNECTIVITY_SERVER);
// 实例化网络状态类
NetworkInfo netwotkInfo = connectivityManager.getActivenetworkInfo();
//--> log.v(TAG, networkInfo.isAvailable());
```

注册权限:

AndroidManifest.xml

```xml
<uses-permission android:name:"android.permission.ACCESS_NETWORK_STAT"/>
```

#### 静态注册

静态注册可以程序在未启动的情况下接收到广播

1. `new->other->Broadcast Receiver`

2. 命名, 选择`Enable`(启用), `Exported` (允许接收程序外的广播), 打开后在`onReceive`内重写逻辑

   AndroidManifest.xml的 `<application>`标签内多了一个**`<recevier>`标签**, 功能类似于`<activity>`

3. 在`<recevier>`内声明要监听的广播

   ```xml
   <receiver
        android:name:".已声明的广播接收器类"
             ...>
       <intent-inflater>
       	<action android:name="xxx">
       </intent-inflater>
   </receiver>
   ```
```

### 发送自定义广播

#### 发送标准广播

设已经有一个`MyBroadcastReceiver`类, 继承了`BroadcastReceiver`类, 并且实现了简单的`onReceive`方法

AndroidManifest.xml

​```xml
<receiver
     android:name:".MyBroadcastReceiver"
          ...>
    <intent-inflater>
    	<action android:name="com.example.broadcast.MY_BROADCAST">
    </intent-inflater>
</receiver>
```

意思是让`MyBroadcastReceiver`类可以接收一条`com.example.broadcast.MY_BROADCAST`广播

现在在一个活动内, 假设一个按钮触发了发送广播的事件

```java
public void onClick(View v){
    // 创建intent实例, 构造方法传入广播名
    Intent intent = new Intent("com.example.broadcast.MY_BROADCAST");
    // 发送广播
    sendbroadcast(intent);
}
```

#### 发送有序广播

有先后接受顺序的广播, 可以通过**对广播接收器设置优先级**实现

发送有序广播只要将`sendBroadcast(intent)`改为`sendOrderedBroadcast(intent, null)`

第二个传入权限的字符串, 一般null即可

对接收器优先级`android:priority="xxx"`

```xml
<receiver
     android:name:".MyBroadcastReceiver"
          ...>
    <intent-inflater
         android:priority="100"
                     >
    	<action android:name="com.example.broadcast.MY_BROADCAST">
    </intent-inflater>
</receiver>
```

如果高优先级的接收器捕捉到了广播, 可以在处理逻辑内调用`abortBroadcast()`函数, 低优先级的无法收到这条广播.

* 以上写法发送的均为全局广播

#### 发送本地广播

```java
public class MainActivity extends AppCompatActivity{
    private IntentFilter intentFilter; 
    private LocalReciver localReciver;
    // 新增的本地广播管理器
    private LocalBroadcastManager localBroadcastManager;
    
    @override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.xxx);

        // 不同之处 获取实例
        localBroadcastManager = LocalBroadcastManager.getInstance(this);
        intentFilter = new IntentFilter();
        intentFilter.addAction("com.example.broadcast.MY_BROADCAST");
        localReciver = new LocalReciver();
        // 不同之处 建立本地广播接收器
        localBroadcastManager.resigerReciver(networkChangeReceiver, intentFilter);
        
        Button btn = (Button)findViewById(R.id.xxx);
        btn.setOnClickListener(View.OnClickListener(){
            public void onClick(){
                 Intent intent = new Intent("com.example.broadcast.MY_BROADCAST");
                // 不同之处 发送本地广播
                localBroadcastManager.sendBroadcast(intent);
            }
        });
    }
    
    protected void onDestory(){
        super.onDestory();
        // 不同之处 销毁本地广播接收器
        localBroadcastManager.unregsiterReceiver(networkChangeReceiver)
    }
    class LocalReciver extends BroadcastReceiver{
        @override
        public void onReceive(Context context, Intent intent){
            Toast.makeText(...).show();
        }
    } 
}
```

### 最佳实践  强制下线

增加一层`BaseActivity`, 里面实现广播接收器功能和活动队列管理功能



## 第六章 持久化存储

文件存储, SharedPreference, 数据库

### 文件存储

不推荐, 适用于简单无格式文本

#### 写

类似Java提供的文件存储方法

context 类中提供了一个`openFileOutput()`方法, 接收两个参数, 返回FileOutputStream对象     

* 文件名 String
* 文件操作模式 `MODE_PRIVATE` (覆盖) `MODE_APPEND`(追加)

注意, 不定义路径, 所有文件都保存在`/data/data/<packagename>/files/`目录下

```java
public void save(){
    String data = "data";
    FileOutputStream out = null;
    BufferWriter writer= null;
    try{
        out = openFileOutput("data", Context.MODE_PRIVATE);
        writer = new BufferWriter(new OutputStreamWriter(out));
        writer.write(data);
    }catch(IOException e){
        e.printStacktrace();
    }finally{
        try{
            if(writer != null){
                writer.close();
            }catch(IOException e){
                e.printStacktrace();
            }
        }
    }
}
```

#### 读

Context类中还有`openFileInput()`方法, 只接受一个参数文件名String, 返回FileInputStream对象

```java
public String load(){
    StringBulider content = new StringBulider();
    FileInputStream in = null;
    BufferReader reader = null;
    try{
        in = openFileInput("data");
        reader = new BufferReader(new InputStreamReader(in));
        String singleLine = "";
        while((singleline = reader.readline())!= null){
            content.append(singleline);
        }
    }catch(IOException e){
        e.printStacktrace();
    }finally{
        try{
            if(reader != null){
                reader.close();
            }catch(IOException e){
                e.printStacktrace();
            }
        }
    }
    return content.toString();
}
```

### SharedPreference存储

* 键值对存储
* 支持指定数据类型
* xml文件保存

#### 获取SharedPreference对象的方法

1. Context类中的`getSharedPreferences()`方法
   * 第一个参数, 文件名String 不存在则会创建
   * 第二个参数 打开模式 只有`MODE_PRIVATE`可选

2. Activity类中的`getSharedPreferences()`方法

   ​	只有一个参数 打开模式 只有`MODE_PRIVATE`可选

   ​	会将自己的活动类名当作文件名

3. PreferenceManager类中的`getDefaultSharedPreferences()`方法

   接收一个context参数 包名当作文件名

#### 写

```java
onClick(){
    // 1. 调用SharePreferences对象中的edit()方法获取一个SharePreferences.Editor对象
    SharePreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();
    
    // 2. 向SharePreferences.Editor对象中添加数据
    editor.putString("key_String", "value_String");
    editor.putBoolean("key_boolean", true);//ect...    	
    
    // 3. apply()方法提交
    editor.apply();
}
    
```

#### 读

```java
onClick(){
    // 1.获取SharePreferences对象
    SharedPreferences pref = getSharedPreferences("data", MODE_PRIVATE);
    
    // 2.根据不同的数据用不同的get方法(类似Intent取值)
    	// 第一个参数key 第二个参数默认值,当key找不到对应时的默认值
    String string = pref.getString("key_String", "default String");
    boolean bool = pref.getBoolean("key_boolean", false);
}
```

